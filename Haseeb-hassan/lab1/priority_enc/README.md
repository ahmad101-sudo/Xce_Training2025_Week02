# 8-to-3 Priority Encoder - Lab 1

## Problem Description

This lab implements an 8-to-3 priority encoder that converts 8 input lines into a 3-bit binary code representing the highest-priority active input. The encoder includes an enable control and a valid output to indicate when at least one input is active. Priority is determined by bit position, with bit 7 having the highest priority and bit 0 having the lowest priority. When multiple inputs are active simultaneously, the encoder outputs the position of the highest-priority (leftmost) active bit.

## Approach

The priority encoder is implemented using **combinational logic** with the following key components:

- **Enable Control**: When enable=0, the encoder is disabled and outputs are forced to inactive states
- **Priority Logic**: Uses `casez` statement with don't-care conditions (?) to implement priority encoding efficiently
- **Valid Signal Generation**: Uses OR reduction of all input bits to determine if any input is active
- **MSB-First Priority**: Scans from data_in[7] (highest priority) to data_in[0] (lowest priority)

The design uses a `casez` statement which allows pattern matching with don't-care bits, making the priority encoding logic clean and readable. The valid signal is generated by ORing all input bits to detect any active input when the encoder is enabled.

## Folder Structure

```
priority_enc/
├── priority_encoder_8to3.sv              
├── tb_priority_encoder_8to3.sv           
├── documentation/
│   └── truthtable
│   └── signal_description.txt
│   └── waves 
└── README.md                             
```

## How to Run

### Prerequisites
- SystemVerilog compatible simulator (ModelSim, QuestaSim, Vivado, etc.)

### Simulation Steps

#### Using ModelSim/QuestaSim:
```bash
# Compile the design and testbench
vlog priority_encoder_8to3.sv tb_priority_encoder_8to3.sv

# Start simulation
vsim tb_priority_encoder_8to3

# Run the simulation
run -all
```

#### Using Vivado:
```bash
# Create new project and add source files
# Set tb_priority_encoder_8to3 as top module for simulation
# Run behavioral simulation
```

The testbench automatically tests various scenarios including disabled state, one-hot inputs, and multiple active inputs, then finishes automatically.

## Examples

### Test Case 1: Encoder Disabled
- **Input**: enable = 0, data_in = 8'b00000000
- **Expected Output**: encoded_out = 3'b000, valid = 0

### Test Case 2: Single Active Input (Bit 0)
- **Input**: enable = 1, data_in = 8'b00000001
- **Expected Output**: encoded_out = 3'b000, valid = 1

### Test Case 3: Single Active Input (Bit 2)
- **Input**: enable = 1, data_in = 8'b00000100
- **Expected Output**: encoded_out = 3'b010, valid = 1

### Test Case 4: Single Active Input (Bit 5)
- **Input**: enable = 1, data_in = 8'b00100000
- **Expected Output**: encoded_out = 3'b101, valid = 1

### Test Case 5: Single Active Input (Bit 7 - Highest Priority)
- **Input**: enable = 1, data_in = 8'b10000000
- **Expected Output**: encoded_out = 3'b111, valid = 1

### Test Case 6: Multiple Active Inputs (Priority Test)
- **Input**: enable = 1, data_in = 8'b10101010
- **Expected Output**: encoded_out = 3'b111, valid = 1 (Bit 7 wins due to highest priority)

### Test Case 7: Encoder Disabled with Active Inputs
- **Input**: enable = 0, data_in = 8'b11111111
- **Expected Output**: encoded_out = 3'b000, valid = 0